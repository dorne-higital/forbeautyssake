import {
  createBlock,
  createTextVNode,
  defineAsyncComponent,
  defineComponent,
  h,
  inject,
  mergeProps,
  onMounted,
  openBlock,
  ref,
  resolveDynamicComponent
} from "./chunk-2435C5CU.js";
import "./chunk-F3FYYIAV.js";

// node_modules/@storyblok/vue/dist/storyblok-vue.mjs
var H = false;
var U = [];
var ie = (s) => new Promise((e, t) => {
  if (typeof window > "u" || (window.storyblokRegisterEvent = (o) => {
    if (window.location === window.parent.location) {
      console.warn("You are not in Draft Mode or in the Visual Editor.");
      return;
    }
    H ? o() : U.push(o);
  }, document.getElementById("storyblok-javascript-bridge")))
    return;
  const r = document.createElement("script");
  r.async = true, r.src = s, r.id = "storyblok-javascript-bridge", r.onerror = (o) => t(o), r.onload = (o) => {
    U.forEach((n) => n()), H = true, e(o);
  }, document.getElementsByTagName("head")[0].appendChild(r);
});
var ae = Object.defineProperty;
var le = (s, e, t) => e in s ? ae(s, e, { enumerable: true, configurable: true, writable: true, value: t }) : s[e] = t;
var d = (s, e, t) => le(s, typeof e != "symbol" ? e + "" : e, t);
function D(s) {
  return !(s !== s || s === 1 / 0 || s === -1 / 0);
}
function ce(s, e, t) {
  if (!D(e))
    throw new TypeError("Expected `limit` to be a finite number");
  if (!D(t))
    throw new TypeError("Expected `interval` to be a finite number");
  const r = [];
  let o = [], n = 0;
  const i = function() {
    n++;
    const a = setTimeout(function() {
      n--, r.length > 0 && i(), o = o.filter(function(p) {
        return p !== a;
      });
    }, t);
    o.indexOf(a) < 0 && o.push(a);
    const u = r.shift();
    u.resolve(s.apply(u.self, u.args));
  }, l = function(...a) {
    const u = this;
    return new Promise(function(p, h2) {
      r.push({
        resolve: p,
        reject: h2,
        args: a,
        self: u
      }), n < e && i();
    });
  };
  return l.abort = function() {
    o.forEach(clearTimeout), o = [], r.forEach(function(a) {
      a.reject(function() {
        Error.call(this, "Throttled function aborted"), this.name = "AbortError";
      });
    }), r.length = 0;
  }, l;
}
var j = class {
  constructor() {
    d(this, "isCDNUrl", (e = "") => e.indexOf("/cdn/") > -1), d(this, "getOptionsPage", (e, t = 25, r = 1) => ({
      ...e,
      per_page: t,
      page: r
    })), d(this, "delay", (e) => new Promise((t) => setTimeout(t, e))), d(this, "arrayFrom", (e = 0, t) => [...Array(e)].map(t)), d(this, "range", (e = 0, t = e) => {
      const r = Math.abs(t - e) || 0, o = e < t ? 1 : -1;
      return this.arrayFrom(r, (n, i) => i * o + e);
    }), d(this, "asyncMap", async (e, t) => Promise.all(e.map(t))), d(this, "flatMap", (e = [], t) => e.map(t).reduce((r, o) => [...r, ...o], [])), d(this, "escapeHTML", function(e) {
      const t = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }, r = /[&<>"']/g, o = RegExp(r.source);
      return e && o.test(e) ? e.replace(r, (n) => t[n]) : e;
    });
  }
  /**
   * @method stringify
   * @param  {Object} params
   * @param  {String} prefix
   * @param  {Boolean} isArray
   * @return {String} Stringified object
   */
  stringify(e, t, r) {
    const o = [];
    for (const n in e) {
      if (!Object.prototype.hasOwnProperty.call(e, n))
        continue;
      const i = e[n], l = r ? "" : encodeURIComponent(n);
      let a;
      typeof i == "object" ? a = this.stringify(
        i,
        t ? t + encodeURIComponent("[" + l + "]") : l,
        Array.isArray(i)
      ) : a = (t ? t + encodeURIComponent("[" + l + "]") : l) + "=" + encodeURIComponent(i), o.push(a);
    }
    return o.join("&");
  }
  /**
   * @method getRegionURL
   * @param  {String} regionCode region code, could be eu, us, cn, ap or ca
   * @return {String} The base URL of the region
   */
  getRegionURL(e) {
    const t = "api.storyblok.com", r = "api-us.storyblok.com", o = "app.storyblokchina.cn", n = "api-ap.storyblok.com", i = "api-ca.storyblok.com";
    switch (e) {
      case "us":
        return r;
      case "cn":
        return o;
      case "ap":
        return n;
      case "ca":
        return i;
      default:
        return t;
    }
  }
};
var he = function(s, e) {
  const t = {};
  for (const r in s) {
    const o = s[r];
    e.indexOf(r) > -1 && o !== null && (t[r] = o);
  }
  return t;
};
var ue = (s) => s === "email";
var pe = () => ({
  singleTag: "hr"
});
var de = () => ({
  tag: "blockquote"
});
var ge = () => ({
  tag: "ul"
});
var fe = (s) => ({
  tag: [
    "pre",
    {
      tag: "code",
      attrs: s.attrs
    }
  ]
});
var me = () => ({
  singleTag: "br"
});
var ye = (s) => ({
  tag: `h${s.attrs.level}`
});
var be = (s) => ({
  singleTag: [
    {
      tag: "img",
      attrs: he(s.attrs, ["src", "alt", "title"])
    }
  ]
});
var ke = () => ({
  tag: "li"
});
var ve = () => ({
  tag: "ol"
});
var $e = () => ({
  tag: "p"
});
var Te = (s) => ({
  tag: [
    {
      tag: "span",
      attrs: {
        "data-type": "emoji",
        "data-name": s.attrs.name,
        emoji: s.attrs.emoji
      }
    }
  ]
});
var Re = () => ({
  tag: "b"
});
var we = () => ({
  tag: "s"
});
var _e = () => ({
  tag: "u"
});
var Se = () => ({
  tag: "strong"
});
var Ee = () => ({
  tag: "code"
});
var xe = () => ({
  tag: "i"
});
var Ie = (s) => {
  if (!s.attrs)
    return {
      tag: ""
    };
  const e = new j().escapeHTML, t = { ...s.attrs }, { linktype: r = "url" } = s.attrs;
  if (delete t.linktype, t.href && (t.href = e(s.attrs.href || "")), ue(r) && (t.href = `mailto:${t.href}`), t.anchor && (t.href = `${t.href}#${t.anchor}`, delete t.anchor), t.custom) {
    for (const o in t.custom)
      t[o] = t.custom[o];
    delete t.custom;
  }
  return {
    tag: [
      {
        tag: "a",
        attrs: t
      }
    ]
  };
};
var je = (s) => ({
  tag: [
    {
      tag: "span",
      attrs: s.attrs
    }
  ]
});
var Ce = () => ({
  tag: "sub"
});
var Oe = () => ({
  tag: "sup"
});
var Ae = (s) => ({
  tag: [
    {
      tag: "span",
      attrs: s.attrs
    }
  ]
});
var Le = (s) => {
  var e;
  return (e = s.attrs) != null && e.color ? {
    tag: [
      {
        tag: "span",
        attrs: {
          style: `background-color:${s.attrs.color};`
        }
      }
    ]
  } : {
    tag: ""
  };
};
var Pe = (s) => {
  var e;
  return (e = s.attrs) != null && e.color ? {
    tag: [
      {
        tag: "span",
        attrs: {
          style: `color:${s.attrs.color}`
        }
      }
    ]
  } : {
    tag: ""
  };
};
var Ne = {
  nodes: {
    horizontal_rule: pe,
    blockquote: de,
    bullet_list: ge,
    code_block: fe,
    hard_break: me,
    heading: ye,
    image: be,
    list_item: ke,
    ordered_list: ve,
    paragraph: $e,
    emoji: Te
  },
  marks: {
    bold: Re,
    strike: we,
    underline: _e,
    strong: Se,
    code: Ee,
    italic: xe,
    link: Ie,
    styled: je,
    subscript: Ce,
    superscript: Oe,
    anchor: Ae,
    highlight: Le,
    textStyle: Pe
  }
};
var Me = function(s) {
  const e = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  }, t = /[&<>"']/g, r = RegExp(t.source);
  return s && r.test(s) ? s.replace(t, (o) => e[o]) : s;
};
var z = false;
var He = class {
  constructor(e) {
    d(this, "marks"), d(this, "nodes"), e || (e = Ne), this.marks = e.marks || [], this.nodes = e.nodes || [];
  }
  addNode(e, t) {
    this.nodes[e] = t;
  }
  addMark(e, t) {
    this.marks[e] = t;
  }
  render(e, t = { optimizeImages: false }, r = true) {
    if (!z && r && (console.warn(
      "Warning ⚠️: The RichTextResolver class is deprecated and will be removed in the next major release. Please use the `@storyblok/richtext` package instead. https://github.com/storyblok/richtext/"
    ), z = true), e && e.content && Array.isArray(e.content)) {
      let o = "";
      return e.content.forEach((n) => {
        o += this.renderNode(n);
      }), t.optimizeImages ? this.optimizeImages(o, t.optimizeImages) : o;
    }
    return console.warn(
      `The render method must receive an Object with a "content" field.
			The "content" field must be an array of nodes as the type ISbRichtext.
			ISbRichtext:
				content?: ISbRichtext[]
				marks?: ISbRichtext[]
				attrs?: any
				text?: string
				type: string
				
				Example:
				{
					content: [
						{
							content: [
								{
									text: 'Hello World',
									type: 'text'
								}
							],
							type: 'paragraph'
						}
					],
					type: 'doc'
				}`
    ), "";
  }
  optimizeImages(e, t) {
    let r = 0, o = 0, n = "", i = "";
    typeof t != "boolean" && (typeof t.width == "number" && t.width > 0 && (n += `width="${t.width}" `, r = t.width), typeof t.height == "number" && t.height > 0 && (n += `height="${t.height}" `, o = t.height), (t.loading === "lazy" || t.loading === "eager") && (n += `loading="${t.loading}" `), typeof t.class == "string" && t.class.length > 0 && (n += `class="${t.class}" `), t.filters && (typeof t.filters.blur == "number" && t.filters.blur >= 0 && t.filters.blur <= 100 && (i += `:blur(${t.filters.blur})`), typeof t.filters.brightness == "number" && t.filters.brightness >= -100 && t.filters.brightness <= 100 && (i += `:brightness(${t.filters.brightness})`), t.filters.fill && (t.filters.fill.match(/[0-9A-Fa-f]{6}/g) || t.filters.fill === "transparent") && (i += `:fill(${t.filters.fill})`), t.filters.format && ["webp", "png", "jpeg"].includes(t.filters.format) && (i += `:format(${t.filters.format})`), typeof t.filters.grayscale == "boolean" && t.filters.grayscale && (i += ":grayscale()"), typeof t.filters.quality == "number" && t.filters.quality >= 0 && t.filters.quality <= 100 && (i += `:quality(${t.filters.quality})`), t.filters.rotate && [90, 180, 270].includes(t.filters.rotate) && (i += `:rotate(${t.filters.rotate})`), i.length > 0 && (i = "/filters" + i))), n.length > 0 && (e = e.replace(/<img/g, `<img ${n.trim()}`));
    const l = r > 0 || o > 0 || i.length > 0 ? `${r}x${o}${i}` : "";
    return e = e.replace(
      /a.storyblok.com\/f\/(\d+)\/([^.]+)\.(gif|jpg|jpeg|png|tif|tiff|bmp)/g,
      `a.storyblok.com/f/$1/$2.$3/m/${l}`
    ), typeof t != "boolean" && (t.sizes || t.srcset) && (e = e.replace(/<img.*?src=["|'](.*?)["|']/g, (a) => {
      var u, p;
      const h2 = a.match(
        /a.storyblok.com\/f\/(\d+)\/([^.]+)\.(gif|jpg|jpeg|png|tif|tiff|bmp)/g
      );
      if (h2 && h2.length > 0) {
        const m = {
          srcset: (u = t.srcset) == null ? void 0 : u.map((y) => {
            if (typeof y == "number")
              return `//${h2}/m/${y}x0${i} ${y}w`;
            if (typeof y == "object" && y.length === 2) {
              let w = 0, x = 0;
              return typeof y[0] == "number" && (w = y[0]), typeof y[1] == "number" && (x = y[1]), `//${h2}/m/${w}x${x}${i} ${w}w`;
            }
          }).join(", "),
          sizes: (p = t.sizes) == null ? void 0 : p.map((y) => y).join(", ")
        };
        let $ = "";
        return m.srcset && ($ += `srcset="${m.srcset}" `), m.sizes && ($ += `sizes="${m.sizes}" `), a.replace(/<img/g, `<img ${$.trim()}`);
      }
      return a;
    })), e;
  }
  renderNode(e) {
    const t = [];
    e.marks && e.marks.forEach((o) => {
      const n = this.getMatchingMark(o);
      n && n.tag !== "" && t.push(this.renderOpeningTag(n.tag));
    });
    const r = this.getMatchingNode(e);
    return r && r.tag && t.push(this.renderOpeningTag(r.tag)), e.content ? e.content.forEach((o) => {
      t.push(this.renderNode(o));
    }) : e.text ? t.push(Me(e.text)) : r && r.singleTag ? t.push(this.renderTag(r.singleTag, " /")) : r && r.html ? t.push(r.html) : e.type === "emoji" && t.push(this.renderEmoji(e)), r && r.tag && t.push(this.renderClosingTag(r.tag)), e.marks && e.marks.slice(0).reverse().forEach((o) => {
      const n = this.getMatchingMark(o);
      n && n.tag !== "" && t.push(this.renderClosingTag(n.tag));
    }), t.join("");
  }
  renderTag(e, t) {
    return e.constructor === String ? `<${e}${t}>` : e.map((r) => {
      if (r.constructor === String)
        return `<${r}${t}>`;
      {
        let o = `<${r.tag}`;
        if (r.attrs) {
          for (const n in r.attrs)
            if (Object.prototype.hasOwnProperty.call(r.attrs, n)) {
              const i = r.attrs[n];
              i !== null && (o += ` ${n}="${i}"`);
            }
        }
        return `${o}${t}>`;
      }
    }).join("");
  }
  renderOpeningTag(e) {
    return this.renderTag(e, "");
  }
  renderClosingTag(e) {
    return e.constructor === String ? `</${e}>` : e.slice(0).reverse().map((t) => t.constructor === String ? `</${t}>` : `</${t.tag}>`).join("");
  }
  getMatchingNode(e) {
    const t = this.nodes[e.type];
    if (typeof t == "function")
      return t(e);
  }
  getMatchingMark(e) {
    const t = this.marks[e.type];
    if (typeof t == "function")
      return t(e);
  }
  renderEmoji(e) {
    if (e.attrs.emoji)
      return e.attrs.emoji;
    const t = [
      {
        tag: "img",
        attrs: {
          src: e.attrs.fallbackImage,
          draggable: "false",
          loading: "lazy",
          align: "absmiddle"
        }
      }
    ];
    return this.renderTag(t, " /");
  }
};
var C = He;
var Ue = class {
  constructor(e) {
    d(this, "baseURL"), d(this, "timeout"), d(this, "headers"), d(this, "responseInterceptor"), d(this, "fetch"), d(this, "ejectInterceptor"), d(this, "url"), d(this, "parameters"), d(this, "fetchOptions"), this.baseURL = e.baseURL, this.headers = e.headers || new Headers(), this.timeout = e != null && e.timeout ? e.timeout * 1e3 : 0, this.responseInterceptor = e.responseInterceptor, this.fetch = (...t) => e.fetch ? e.fetch(...t) : fetch(...t), this.ejectInterceptor = false, this.url = "", this.parameters = {}, this.fetchOptions = {};
  }
  /**
   *
   * @param url string
   * @param params ISbStoriesParams
   * @returns Promise<ISbResponse | Error>
   */
  get(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("get");
  }
  post(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("post");
  }
  put(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("put");
  }
  delete(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("delete");
  }
  async _responseHandler(e) {
    const t = [], r = {
      data: {},
      headers: {},
      status: 0,
      statusText: ""
    };
    e.status !== 204 && await e.json().then((o) => {
      r.data = o;
    });
    for (const o of e.headers.entries())
      t[o[0]] = o[1];
    return r.headers = { ...t }, r.status = e.status, r.statusText = e.statusText, r;
  }
  async _methodHandler(e) {
    let t = `${this.baseURL}${this.url}`, r = null;
    if (e === "get") {
      const a = new j();
      t = `${this.baseURL}${this.url}?${a.stringify(
        this.parameters
      )}`;
    } else
      r = JSON.stringify(this.parameters);
    const o = new URL(t), n = new AbortController(), { signal: i } = n;
    let l;
    this.timeout && (l = setTimeout(() => n.abort(), this.timeout));
    try {
      const a = await this.fetch(`${o}`, {
        method: e,
        headers: this.headers,
        body: r,
        signal: i,
        ...this.fetchOptions
      });
      this.timeout && clearTimeout(l);
      const u = await this._responseHandler(
        a
      );
      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(u)) : this._statusHandler(u);
    } catch (a) {
      return {
        message: a
      };
    }
  }
  setFetchOptions(e = {}) {
    Object.keys(e).length > 0 && "method" in e && delete e.method, this.fetchOptions = { ...e };
  }
  eject() {
    this.ejectInterceptor = true;
  }
  _statusHandler(e) {
    const t = /20[0-6]/g;
    return new Promise((r, o) => {
      if (t.test(`${e.status}`))
        return r(e);
      const n = {
        message: e.statusText,
        status: e.status,
        response: Array.isArray(e.data) ? e.data[0] : e.data.error || e.data.slug
      };
      o(n);
    });
  }
};
var De = Ue;
var B = "SB-Agent";
var L = {
  defaultAgentName: "SB-JS-CLIENT",
  defaultAgentVersion: "SB-Agent-Version",
  packageVersion: "6.0.0"
};
var I = {};
var _ = {};
var ze = class {
  /**
   *
   * @param config ISbConfig interface
   * @param endpoint string, optional
   */
  constructor(e, t) {
    d(this, "client"), d(this, "maxRetries"), d(this, "retriesDelay"), d(this, "throttle"), d(this, "accessToken"), d(this, "cache"), d(this, "helpers"), d(this, "resolveCounter"), d(this, "relations"), d(this, "links"), d(this, "richTextResolver"), d(this, "resolveNestedRelations"), d(this, "stringifiedStoriesCache");
    let r = e.endpoint || t;
    if (!r) {
      const i = new j().getRegionURL, l = e.https === false ? "http" : "https";
      e.oauthToken ? r = `${l}://${i(e.region)}/v1` : r = `${l}://${i(e.region)}/v2`;
    }
    const o = new Headers();
    o.set("Content-Type", "application/json"), o.set("Accept", "application/json"), e.headers && (e.headers.constructor.name === "Headers" ? e.headers.entries().toArray() : Object.entries(e.headers)).forEach(([i, l]) => {
      o.set(i, l);
    }), o.has(B) || (o.set(B, L.defaultAgentName), o.set(
      L.defaultAgentVersion,
      L.packageVersion
    ));
    let n = 5;
    e.oauthToken && (o.set("Authorization", e.oauthToken), n = 3), e.rateLimit && (n = e.rateLimit), e.richTextSchema ? this.richTextResolver = new C(e.richTextSchema) : this.richTextResolver = new C(), e.componentResolver && this.setComponentResolver(e.componentResolver), this.maxRetries = e.maxRetries || 10, this.retriesDelay = 300, this.throttle = ce(this.throttledRequest, n, 1e3), this.accessToken = e.accessToken || "", this.relations = {}, this.links = {}, this.cache = e.cache || { clear: "manual" }, this.helpers = new j(), this.resolveCounter = 0, this.resolveNestedRelations = e.resolveNestedRelations || true, this.stringifiedStoriesCache = {}, this.client = new De({
      baseURL: r,
      timeout: e.timeout || 0,
      headers: o,
      responseInterceptor: e.responseInterceptor,
      fetch: e.fetch
    });
  }
  setComponentResolver(e) {
    this.richTextResolver.addNode("blok", (t) => {
      let r = "";
      return t.attrs.body && t.attrs.body.forEach((o) => {
        r += e(o.component, o);
      }), {
        html: r
      };
    });
  }
  parseParams(e) {
    return e.token || (e.token = this.getToken()), e.cv || (e.cv = _[e.token]), Array.isArray(e.resolve_relations) && (e.resolve_relations = e.resolve_relations.join(",")), typeof e.resolve_relations < "u" && (e.resolve_level = 2), e;
  }
  factoryParamOptions(e, t) {
    return this.helpers.isCDNUrl(e) ? this.parseParams(t) : t;
  }
  makeRequest(e, t, r, o, n) {
    const i = this.factoryParamOptions(
      e,
      this.helpers.getOptionsPage(t, r, o)
    );
    return this.cacheResponse(e, i, void 0, n);
  }
  get(e, t, r) {
    t || (t = {});
    const o = `/${e}`, n = this.factoryParamOptions(o, t);
    return this.cacheResponse(o, n, void 0, r);
  }
  async getAll(e, t, r, o) {
    const n = (t == null ? void 0 : t.per_page) || 25, i = `/${e}`, l = i.split("/"), a = r || l[l.length - 1], u = 1, p = await this.makeRequest(
      i,
      t,
      n,
      u,
      o
    ), h2 = p.total ? Math.ceil(p.total / n) : 1, m = await this.helpers.asyncMap(
      this.helpers.range(u, h2),
      ($) => this.makeRequest(i, t, n, $ + 1, o)
    );
    return this.helpers.flatMap(
      [p, ...m],
      ($) => Object.values($.data[a])
    );
  }
  post(e, t, r) {
    const o = `/${e}`;
    return Promise.resolve(this.throttle("post", o, t, r));
  }
  put(e, t, r) {
    const o = `/${e}`;
    return Promise.resolve(this.throttle("put", o, t, r));
  }
  delete(e, t, r) {
    const o = `/${e}`;
    return Promise.resolve(this.throttle("delete", o, t, r));
  }
  getStories(e, t) {
    return this._addResolveLevel(e), this.get("cdn/stories", e, t);
  }
  getStory(e, t, r) {
    return this._addResolveLevel(t), this.get(`cdn/stories/${e}`, t, r);
  }
  getToken() {
    return this.accessToken;
  }
  ejectInterceptor() {
    this.client.eject();
  }
  _addResolveLevel(e) {
    typeof e.resolve_relations < "u" && (e.resolve_level = 2);
  }
  _cleanCopy(e) {
    return JSON.parse(JSON.stringify(e));
  }
  _insertLinks(e, t, r) {
    const o = e[t];
    o && o.fieldtype == "multilink" && o.linktype == "story" && typeof o.id == "string" && this.links[r][o.id] ? o.story = this._cleanCopy(this.links[r][o.id]) : o && o.linktype === "story" && typeof o.uuid == "string" && this.links[r][o.uuid] && (o.story = this._cleanCopy(this.links[r][o.uuid]));
  }
  /**
   *
   * @param resolveId A counter number as a string
   * @param uuid The uuid of the story
   * @returns string | object
   */
  getStoryReference(e, t) {
    return this.relations[e][t] ? (this.stringifiedStoriesCache[t] || (this.stringifiedStoriesCache[t] = JSON.stringify(
      this.relations[e][t]
    )), JSON.parse(this.stringifiedStoriesCache[t])) : t;
  }
  _insertRelations(e, t, r, o) {
    r.indexOf(`${e.component}.${t}`) > -1 && (typeof e[t] == "string" ? e[t] = this.getStoryReference(o, e[t]) : Array.isArray(e[t]) && (e[t] = e[t].map((n) => this.getStoryReference(o, n)).filter(Boolean)));
  }
  iterateTree(e, t, r) {
    const o = (n) => {
      if (n != null) {
        if (n.constructor === Array)
          for (let i = 0; i < n.length; i++)
            o(n[i]);
        else if (n.constructor === Object) {
          if (n._stopResolving)
            return;
          for (const i in n)
            (n.component && n._uid || n.type === "link") && (this._insertRelations(
              n,
              i,
              t,
              r
            ), this._insertLinks(
              n,
              i,
              r
            )), o(n[i]);
        }
      }
    };
    o(e.content);
  }
  async resolveLinks(e, t, r) {
    let o = [];
    if (e.link_uuids) {
      const n = e.link_uuids.length, i = [], l = 50;
      for (let a = 0; a < n; a += l) {
        const u = Math.min(n, a + l);
        i.push(e.link_uuids.slice(a, u));
      }
      for (let a = 0; a < i.length; a++)
        (await this.getStories({
          per_page: l,
          language: t.language,
          version: t.version,
          by_uuids: i[a].join(",")
        })).data.stories.forEach(
          (u) => {
            o.push(u);
          }
        );
    } else
      o = e.links;
    o.forEach((n) => {
      this.links[r][n.uuid] = {
        ...n,
        _stopResolving: true
      };
    });
  }
  async resolveRelations(e, t, r) {
    let o = [];
    if (e.rel_uuids) {
      const n = e.rel_uuids.length, i = [], l = 50;
      for (let a = 0; a < n; a += l) {
        const u = Math.min(n, a + l);
        i.push(e.rel_uuids.slice(a, u));
      }
      for (let a = 0; a < i.length; a++)
        (await this.getStories({
          per_page: l,
          language: t.language,
          version: t.version,
          by_uuids: i[a].join(","),
          excluding_fields: t.excluding_fields
        })).data.stories.forEach((u) => {
          o.push(u);
        });
    } else
      o = e.rels;
    o && o.length > 0 && o.forEach((n) => {
      this.relations[r][n.uuid] = {
        ...n,
        _stopResolving: true
      };
    });
  }
  /**
   *
   * @param responseData
   * @param params
   * @param resolveId
   * @description Resolves the relations and links of the stories
   * @returns Promise<void>
   *
   */
  async resolveStories(e, t, r) {
    var o, n;
    let i = [];
    if (this.links[r] = {}, this.relations[r] = {}, typeof t.resolve_relations < "u" && t.resolve_relations.length > 0 && (typeof t.resolve_relations == "string" && (i = t.resolve_relations.split(",")), await this.resolveRelations(e, t, r)), t.resolve_links && ["1", "story", "url", "link"].indexOf(t.resolve_links) > -1 && ((o = e.links) != null && o.length || (n = e.link_uuids) != null && n.length) && await this.resolveLinks(e, t, r), this.resolveNestedRelations)
      for (const l in this.relations[r])
        this.iterateTree(
          this.relations[r][l],
          i,
          r
        );
    e.story ? this.iterateTree(e.story, i, r) : e.stories.forEach((l) => {
      this.iterateTree(l, i, r);
    }), this.stringifiedStoriesCache = {}, delete this.links[r], delete this.relations[r];
  }
  async cacheResponse(e, t, r, o) {
    const n = this.helpers.stringify({ url: e, params: t }), i = this.cacheProvider();
    if (this.cache.clear === "auto" && t.version === "draft" && await this.flushCache(), t.version === "published" && e != "/cdn/spaces/me") {
      const l = await i.get(n);
      if (l)
        return Promise.resolve(l);
    }
    return new Promise(async (l, a) => {
      var u;
      try {
        const p = await this.throttle("get", e, t, o);
        if (p.status !== 200)
          return a(p);
        let h2 = { data: p.data, headers: p.headers };
        if ((u = p.headers) != null && u["per-page"] && (h2 = Object.assign({}, h2, {
          perPage: p.headers["per-page"] ? parseInt(p.headers["per-page"]) : 0,
          total: p.headers["per-page"] ? parseInt(p.headers.total) : 0
        })), h2.data.story || h2.data.stories) {
          const m = this.resolveCounter = ++this.resolveCounter % 1e3;
          await this.resolveStories(h2.data, t, `${m}`);
        }
        return t.version === "published" && e != "/cdn/spaces/me" && await i.set(n, h2), h2.data.cv && t.token && (t.version === "draft" && _[t.token] != h2.data.cv && await this.flushCache(), _[t.token] = t.cv ? t.cv : h2.data.cv), l(h2);
      } catch (p) {
        if (p.response && p.status === 429 && (r = typeof r > "u" ? 0 : r + 1, r < this.maxRetries))
          return console.log(
            `Hit rate limit. Retrying in ${this.retriesDelay / 1e3} seconds.`
          ), await this.helpers.delay(this.retriesDelay), this.cacheResponse(e, t, r).then(l).catch(a);
        a(p);
      }
    });
  }
  throttledRequest(e, t, r, o) {
    return this.client.setFetchOptions(o), this.client[e](t, r);
  }
  cacheVersions() {
    return _;
  }
  cacheVersion() {
    return _[this.accessToken];
  }
  setCacheVersion(e) {
    this.accessToken && (_[this.accessToken] = e);
  }
  clearCacheVersion() {
    this.accessToken && (_[this.accessToken] = 0);
  }
  cacheProvider() {
    switch (this.cache.type) {
      case "memory":
        return {
          get(e) {
            return Promise.resolve(I[e]);
          },
          getAll() {
            return Promise.resolve(I);
          },
          set(e, t) {
            return I[e] = t, Promise.resolve(void 0);
          },
          flush() {
            return I = {}, Promise.resolve(void 0);
          }
        };
      case "custom":
        if (this.cache.custom)
          return this.cache.custom;
      default:
        return {
          get() {
            return Promise.resolve();
          },
          getAll() {
            return Promise.resolve(void 0);
          },
          set() {
            return Promise.resolve(void 0);
          },
          flush() {
            return Promise.resolve(void 0);
          }
        };
    }
  }
  async flushCache() {
    return await this.cacheProvider().flush(), this.clearCacheVersion(), this;
  }
};
var st = (s = {}) => {
  const { apiOptions: e } = s;
  if (!e.accessToken) {
    console.error(
      "You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication"
    );
    return;
  }
  return { storyblokApi: new ze(e) };
};
var Be = (s) => {
  if (typeof s != "object" || typeof s._editable > "u")
    return {};
  try {
    const e = JSON.parse(
      s._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, "")
    );
    return e ? {
      "data-blok-c": JSON.stringify(e),
      "data-blok-uid": e.id + "-" + e.uid
    } : {};
  } catch {
    return {};
  }
};
var b = ((s) => (s.DOCUMENT = "doc", s.HEADING = "heading", s.PARAGRAPH = "paragraph", s.QUOTE = "blockquote", s.OL_LIST = "ordered_list", s.UL_LIST = "bullet_list", s.LIST_ITEM = "list_item", s.CODE_BLOCK = "code_block", s.HR = "horizontal_rule", s.BR = "hard_break", s.IMAGE = "image", s.EMOJI = "emoji", s.COMPONENT = "blok", s))(b || {});
var k = ((s) => (s.BOLD = "bold", s.STRONG = "strong", s.STRIKE = "strike", s.UNDERLINE = "underline", s.ITALIC = "italic", s.CODE = "code", s.LINK = "link", s.ANCHOR = "anchor", s.STYLED = "styled", s.SUPERSCRIPT = "superscript", s.SUBSCRIPT = "subscript", s.TEXT_STYLE = "textStyle", s.HIGHLIGHT = "highlight", s))(k || {});
var J = ((s) => (s.TEXT = "text", s))(J || {});
var S = ((s) => (s.URL = "url", s.STORY = "story", s.ASSET = "asset", s.EMAIL = "email", s))(S || {});
function qe(s, e) {
  if (!e)
    return { src: s, attrs: {} };
  let t = 0, r = 0;
  const o = {}, n = [];
  function i(a, u, p, h2, m) {
    typeof a != "number" || a <= u || a >= p ? console.warn(`[StoryblokRichText] - ${h2.charAt(0).toUpperCase() + h2.slice(1)} value must be a number between ${u} and ${p} (inclusive)`) : m.push(`${h2}(${a})`);
  }
  if (typeof e == "object") {
    if (typeof e.width == "number" && e.width > 0 ? (o.width = e.width, t = e.width) : console.warn("[StoryblokRichText] - Width value must be a number greater than 0"), e.height && typeof e.height == "number" && e.height > 0 ? (o.height = e.height, r = e.height) : console.warn("[StoryblokRichText] - Height value must be a number greater than 0"), e.loading && ["lazy", "eager"].includes(e.loading) && (o.loading = e.loading), e.class && (o.class = e.class), e.filters) {
      const { filters: a } = e || {}, { blur: u, brightness: p, fill: h2, format: m, grayscale: $, quality: y, rotate: w } = a || {};
      u && i(u, 0, 100, "blur", n), y && i(y, 0, 100, "quality", n), p && i(p, 0, 100, "brightness", n), h2 && n.push(`fill(${h2})`), $ && n.push("grayscale()"), w && [0, 90, 180, 270].includes(e.filters.rotate || 0) && n.push(`rotate(${w})`), m && ["webp", "png", "jpeg"].includes(m) && n.push(`format(${m})`);
    }
    e.srcset && (o.srcset = e.srcset.map((a) => {
      if (typeof a == "number")
        return `${s}/m/${a}x0/${n.length > 0 ? "filters:" + n.join(":") : ""} ${a}w`;
      if (Array.isArray(a) && a.length === 2) {
        const [u, p] = a;
        return `${s}/m/${u}x${p}/${n.length > 0 ? "filters:" + n.join(":") : ""} ${u}w`;
      }
    }).join(", ")), e.sizes && (o.sizes = e.sizes.join(", "));
  }
  let l = `${s}/m/`;
  return t > 0 && r > 0 && (l = `${l}${t}x${r}/`), n.length > 0 && (l = `${l}filters:${n.join(":")}`), {
    src: l,
    attrs: o
  };
}
var Fe = (s = {}) => Object.keys(s).map((e) => `${e}="${s[e]}"`).join(" ");
var Ve = (s = {}) => Object.keys(s).map((e) => `${e}: ${s[e]}`).join("; ");
function Ge(s) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
function Ke(s, e = {}, t) {
  const r = Fe(e);
  return `<${r ? `${s} ${r}` : s}>${Array.isArray(t) ? t.join("") : t || ""}</${s}>`;
}
function Je(s = {}) {
  let e = 0;
  const {
    renderFn: t = Ke,
    textFn: r = Ge,
    resolvers: o = {},
    optimizeImages: n = false
  } = s, i = (c) => (g) => t(c, { ...g.attrs, key: `${c}-${e}` }, g.children || null), l = (c) => {
    const { src: g, alt: f, ...v } = c.attrs || {};
    let T = g, R = {};
    if (n) {
      const { src: Z, attrs: ee } = qe(g, n);
      T = Z, R = ee;
    }
    const Q = {
      src: T,
      alt: f || "",
      key: `img-${e}`,
      ...v,
      ...R
    };
    return t("img", Q, "");
  }, a = (c) => {
    const { level: g, ...f } = c.attrs || {};
    return t(`h${g}`, { ...f, key: `h${g}-${e}` }, c.children);
  }, u = (c) => {
    var g, f, v, T;
    return t("span", {
      "data-type": "emoji",
      "data-name": (g = c.attrs) == null ? void 0 : g.name,
      emoji: (f = c.attrs) == null ? void 0 : f.emoji,
      key: `emoji-${e}`
    }, t("img", {
      src: (v = c.attrs) == null ? void 0 : v.fallbackImage,
      alt: (T = c.attrs) == null ? void 0 : T.alt,
      style: "width: 1.25em; height: 1.25em; vertical-align: text-top",
      draggable: "false",
      loading: "lazy"
    }, ""));
  }, p = (c) => t("pre", { ...c.attrs, key: `code-${e}` }, t("code", { key: `code-${e}` }, c.children || "")), h2 = (c, g = false) => ({ text: f, attrs: v }) => t(c, g ? {
    style: Ve(v),
    key: `${c}-${e}`
  } : { ...v, key: `${c}-${e}` }, f), m = (c) => O(c), $ = (c) => {
    const { marks: g, ...f } = c;
    return "text" in c ? g ? g.reduce(
      (v, T) => m({ ...T, text: v }),
      // Fix: Ensure render function returns a string
      m({ ...f, children: f.children })
      // Fix: Cast children to string
    ) : r(f.text) : "";
  }, y = (c) => {
    const { linktype: g, href: f, anchor: v, ...T } = c.attrs || {};
    let R = "";
    switch (g) {
      case S.ASSET:
      case S.URL:
        R = f;
        break;
      case S.EMAIL:
        R = `mailto:${f}`;
        break;
      case S.STORY:
        R = f;
        break;
    }
    return v && (R = `${R}#${v}`), t("a", { ...T, href: R, key: `a-${e}` }, c.text);
  }, w = (c) => {
    var g, f;
    return console.warn("[StoryblokRichtText] - BLOK resolver is not available for vanilla usage"), t("span", {
      blok: (g = c == null ? void 0 : c.attrs) == null ? void 0 : g.body[0],
      id: (f = c.attrs) == null ? void 0 : f.id,
      key: `component-${e}`,
      style: "display: none"
    }, "");
  }, x = new Map([
    [b.DOCUMENT, i("div")],
    [b.HEADING, a],
    [b.PARAGRAPH, i("p")],
    [b.UL_LIST, i("ul")],
    [b.OL_LIST, i("ol")],
    [b.LIST_ITEM, i("li")],
    [b.IMAGE, l],
    [b.EMOJI, u],
    [b.CODE_BLOCK, p],
    [b.HR, i("hr")],
    [b.BR, i("br")],
    [b.QUOTE, i("blockquote")],
    [b.COMPONENT, w],
    [J.TEXT, $],
    [k.LINK, y],
    [k.ANCHOR, y],
    [k.STYLED, h2("span", true)],
    [k.BOLD, h2("strong")],
    [k.TEXT_STYLE, h2("span", true)],
    [k.ITALIC, h2("em")],
    [k.UNDERLINE, h2("u")],
    [k.STRIKE, h2("s")],
    [k.CODE, h2("code")],
    [k.SUPERSCRIPT, h2("sup")],
    [k.SUBSCRIPT, h2("sub")],
    [k.HIGHLIGHT, h2("mark")],
    ...Object.entries(o).map(([c, g]) => [c, g])
  ]);
  function M(c) {
    e += 1;
    const g = x.get(c.type);
    if (!g)
      return console.error("<Storyblok>", `No resolver found for node type ${c.type}`), "";
    if (c.type === "text")
      return g(c);
    const f = c.content ? c.content.map(O) : void 0;
    return g({
      ...c,
      children: f
      // Fix: Update the type of 'children' to Node[]
    });
  }
  function O(c) {
    return Array.isArray(c) ? c.map(M) : M(c);
  }
  return {
    render: O
  };
}
var N;
var q = "https://app.storyblok.com/f/storyblok-v2-latest.js";
var Ye = (s, e, t = {}) => {
  var r;
  const o = !(typeof window > "u") && typeof window.storyblokRegisterEvent < "u", n = +new URL((r = window.location) == null ? void 0 : r.href).searchParams.get(
    "_storyblok"
  ) === s;
  if (!(!o || !n)) {
    if (!s) {
      console.warn("Story ID is not defined. Please provide a valid ID.");
      return;
    }
    window.storyblokRegisterEvent(() => {
      new window.StoryblokBridge(t).on(["input", "published", "change"], (i) => {
        i.action === "input" && i.story.id === s ? e(i.story) : (i.action === "change" || i.action === "published") && i.storyId === s && window.location.reload();
      });
    });
  }
};
var Xe = (s = {}) => {
  var e, t;
  const {
    bridge: r,
    accessToken: o,
    use: n = [],
    apiOptions: i = {},
    richText: l = {},
    bridgeUrl: a
  } = s;
  i.accessToken = i.accessToken || o;
  const u = { bridge: r, apiOptions: i };
  let p = {};
  n.forEach((m) => {
    p = { ...p, ...m(u) };
  }), a && (q = a);
  const h2 = !(typeof window > "u") && ((t = (e = window.location) == null ? void 0 : e.search) == null ? void 0 : t.includes("_storyblok_tk"));
  return r !== false && h2 && ie(q), N = new C(l.schema), l.resolver && Y(N, l.resolver), p;
};
var Y = (s, e) => {
  s.addNode("blok", (t) => {
    let r = "";
    return t.attrs.body.forEach((o) => {
      r += e(o.component, o);
    }), {
      html: r
    };
  });
};
var We = (s) => !s || !(s != null && s.content.some((e) => e.content || e.type === "blok" || e.type === "horizontal_rule"));
var ot = (s, e, t) => {
  let r = t || N;
  if (!r) {
    console.error(
      "Please initialize the Storyblok SDK before calling the renderRichText function"
    );
    return;
  }
  return We(s) ? "" : (e && (r = new C(e.schema), e.resolver && Y(r, e.resolver)), r.render(s, {}, false));
};
var X = defineComponent({
  __name: "StoryblokComponent",
  props: {
    blok: {}
  },
  setup(s, { expose: e }) {
    const t = s, r = ref();
    e({
      value: r
    });
    const o = typeof resolveDynamicComponent(t.blok.component) != "string", n = inject("VueSDKOptions"), i = ref(t.blok.component);
    return o || (n.enableFallbackComponent ? (i.value = n.customFallbackComponent ?? "FallbackComponent", typeof resolveDynamicComponent(i.value) == "string" && console.error(
      `Is the Fallback component "${i.value}" registered properly?`
    )) : console.error(
      `Component could not be found for blok "${t.blok.component}"! Is it defined in main.ts as "app.component("${t.blok.component}", ${t.blok.component});"?`
    )), (l, a) => (openBlock(), createBlock(resolveDynamicComponent(i.value), mergeProps({
      ref_key: "blokRef",
      ref: r
    }, { ...l.$props, ...l.$attrs }), null, 16));
  }
});
var Qe = (s) => {
  var e, t;
  return h(
    X,
    {
      blok: (e = s == null ? void 0 : s.attrs) == null ? void 0 : e.body[0],
      id: (t = s.attrs) == null ? void 0 : t.id
    },
    s.children
  );
};
function Ze(s) {
  const e = {
    renderFn: h,
    textFn: createTextVNode,
    resolvers: {
      [b.COMPONENT]: Qe,
      ...s.resolvers
    }
  };
  return Je(e);
}
var et = defineComponent({
  __name: "StoryblokRichText",
  props: {
    doc: {},
    resolvers: {}
  },
  setup(s) {
    const e = s, { render: t } = Ze({
      resolvers: e.resolvers ?? {}
    }), r = () => t(e.doc);
    return (o, n) => (openBlock(), createBlock(r));
  }
});
var tt = {
  beforeMount(s, e) {
    if (e.value) {
      const t = Be(e.value);
      Object.keys(t).length > 0 && (s.setAttribute("data-blok-c", t["data-blok-c"]), s.setAttribute("data-blok-uid", t["data-blok-uid"]), s.classList.add("storyblok__outline"));
    }
  }
};
var W = (s) => {
  console.error(`You can't use ${s} if you're not loading apiPlugin. Please provide it on StoryblokVue initialization.
    `);
};
var E = null;
var nt = () => (E || W("useStoryblokApi"), E);
var it = async (s, e = {}, t = {}) => {
  const r = ref(null);
  if (t.resolveRelations = t.resolveRelations ?? e.resolve_relations, t.resolveLinks = t.resolveLinks ?? e.resolve_links, onMounted(() => {
    r.value && r.value.id && Ye(
      r.value.id,
      (o) => r.value = o,
      t
    );
  }), E) {
    const { data: o } = await E.get(
      `cdn/stories/${s}`,
      e
    );
    r.value = o.story;
  } else
    W("useStoryblok");
  return r;
};
var at = {
  install(s, e = {}) {
    s.directive("editable", tt), s.component("StoryblokComponent", X), s.component("StoryblokRichText", et), e.enableFallbackComponent && !e.customFallbackComponent && s.component(
      "FallbackComponent",
      defineAsyncComponent(() => import("./FallbackComponent-D9TGQNbC-B7I4VR3L.js"))
    );
    const { storyblokApi: t } = Xe(e);
    E = t, s.provide("VueSDKOptions", e);
  }
};
export {
  b as BlockTypes,
  k as MarkTypes,
  C as RichTextResolver,
  Ne as RichTextSchema,
  X as StoryblokComponent,
  et as StoryblokRichText,
  at as StoryblokVue,
  J as TextTypes,
  st as apiPlugin,
  ot as renderRichText,
  Je as richTextResolver,
  it as useStoryblok,
  nt as useStoryblokApi,
  Ye as useStoryblokBridge,
  Ze as useStoryblokRichText
};
//# sourceMappingURL=@storyblok_vue.js.map
